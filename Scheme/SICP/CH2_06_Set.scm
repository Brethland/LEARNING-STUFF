;;; This is an exercise program in <SICP> CH2.
;;; Mainly about Set and multiset representation.
;;; Author : Brethland, Early 2019.

(define (equal? a b)
    (cond ((and (not (pair? a)) (not (pair? b))) (eq? a b))
          ((or (not (pair? a)) (not (pair? b))) #f)
          (else (and (equal? (car a) (car b)) (equal? (cdr a) (cdr b))))))
(define (element-of-set? x set)
    (cond ((null? set) #f)
          ((equal? x (car set)) #t)
          (else (element-of-set? x (cdr set)))))
(define (adjoin-set x set)
    (cons x set))
(define (intersection-set set1 set2)
    (cond ((or (null? set1) (null? set2)) `())
          ((element-of-set? (car set1) set2)
                (cons (car set1) (intersection-set (cdr set1) set2)))
          (else (intersection-set (cdr set1) set2))))
; (define (union-set set1 set2)
;     (cond ((null? set1) set2)
;           ((null? set2) set1)
;           ((element-of-set? (car set1) set2)
;             (union-set (cdr set1) set2))
;           (else (cons (car set1)
;                     (union-set (cdr set1) set2)))))
(define (number-of-element x set)
    (cond ((null? set) 0)
          ((equal? x (car set)) (+ 1 (number-of-element x (cdr set))))
          (else (number-of-element x (cdr set)))))
; (number-of-element `1 `(1 1 4 5 1 4))
(define (adjoin-set x set)
    (cond ((null? set) (list x))
          ((= x (car set)) set)
          ((< x (car set)) (cons x set))
          (else (cons (car set) (adjoin-set x (cdr set))))))
; (adjoin-set 6 (list 1 3 6 9))
(define (union-set set1 set2)
    (cond ((null? set1) set2)
          ((null? set2) set1)
          (else (let ((x1 (car set1))
                      (x2 (car set2)))
                      (cond ((= x1 x2) (cons x1 (union-set (cdr set1) (cdr set2))))
                            ((< x1 x2) (cons x1 (union-set (cdr set1) set2)))
                            (else (cons x2 (union-set set1 (cdr set2)))))))))
(union-set (list 2 4 6 7) (list 1 4 5 9))
(define (append l1 l2)
      (cond ((null? l1) l2)
            ((null? l2) l1)
            (else (let ((x1 (car l1))
                        (x2 (car l2)))
                        (cond ((< x1 x2) (cons x1 (append (cdr l1) l2))
                               (else (cons x2 (append l1 (cdr l2))))))))))