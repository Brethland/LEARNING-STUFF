;;; This is an exercise program in <SICP> CH2.
;;; Mainly about Multiple Representation for Math and Calculations.
;;; Author : Brethland, Early 2019.

(define (operator exp) (car exp))
(define (operand exp) (cdr exp))
(define (deriv exp var)
    (cond ((number? exp) 0)
          ((variable? exp) (if (same-variable? exp var) 1 0))
          (else ((get `deriv (operator exp)) (operand exp) var))))
(define (install-add-package)
    (define (addend x) (car (cdr x)))
    (define (augend x) (car (cdr (cdr x))))
    (define (make-sum a1 a2)
    (cond ((=number? a1 0) a2)
          ((=number? a2 0) a1)
          ((and (number? a1) (number? a2)) (+ a1 a2))
          (else (tag (list a1 a2)))))
    (define (deriv-plus object var)
        (make-sum (deriv (car object) var)
                  (deriv (car (cdr object)) var)))
    (define (tag x) (attach-tag `+ x))
    (put `deriv `+ deriv-plus)
    (put `make-sum `+ make-sum)
    `done)
(define (install-multiply-package)
    (define (multiplier p) (car (cdr p)))
    (define (multiplicand p) (car (cdr (cdr p))))
    (define (make-product a1 a2)
    (cond ((or (=number? a1 0) (=number? a2 0)) 0)
          ((=number? a1 1) a2)
          ((=number? a2 1) a1)
          ((and (number? a1) (number? a2)) (* a1 a2))
          (else (tag (list a1 a2)))))
    (define (deriv-multi object var)
        ((get `make-sum `+) (make-product (car expr) (deriv (car (cdr expr)) var))
                      (make-product (car (cdr expr)) (deriv (car expr) var))))
    (define (tag x) (attach-tag `* x))
    (put `deriv `* deriv-multi)
    (put `make-product `* make-product)
    `done)
(define (install-exp-package)
    (define (base x) (car (cdr x)))
    (define (exponent x) (car (cdr (cdr x))))
    (define (make-exp a1 a2)
        (cond ((=number? a2 1) a1)
            ((=number? a2 0) 1)
            ((and (number? a1) (number? a2)) (exp a1 a2))
            (else (tag (list a1 a2)))))
    (define (deriv-exp object var)
        ((get `make-product `*) (exponent expr)
                            ((get `make-product `*) (make-exp (base expr) ((get `make-sum `+) (exponent expr) (- 1)))
                                          (deriv (base expr) var))))
    (define (tag x) (attach-tag `** x))
    (put `deriv `** deriv-exp)
    (put `make-exp `** make-exp)
    `done)
(define (make-from-mag-ang mag ang)
    (define dispatch op)
        (cond ((eq? op `real-part) (* mag (cos ang)))
              ((eq? op `imag-part) (* mag (sin ang)))
              ((eq? op `magnitude) x)
              ((eq? op `angle) y)
              (else (display "Unknown op -- MAKE-FROM-MAG-ANG" op)))
    dispatch)
(define (attach-tag type-tag contents)
    (cond (number? (car contents) contents)
          (else (cons type-tag contents))))
(define (type-tag datum)
    (cond ((pair? datum)
            (if (number? (car datum))
                `scheme-number
                (car datum)))
           (else (if (number? datum)
                    `scheme-number
                (display "Bad tagged datum --TYPE-TAG" datum)))))
(define (contents datum)
    (cond ((pair? datum)
            (if (number? (car datum))
                datum
                (cdr datum)))
          (else (if (number? datum)
                    datum
                    (display "Bad tagged datum -- CONTENTS" datum)))))
(define (install-equ-package)
    (define (equ-number x y)
        (= x y))
    (define (equ-rat x y)
        (and (= (number x) (number y))
             (= (denom x) (denom y))))
    (define (equ-complex x y)
        (and (= (real-part x) (real-part y))
             (= (imag-part x) (imag-part y))))
    (put `equal `(scheme-number scheme-number) equ-number)
    (put `equal `(rational rational) equ-rat)
    (put `equal `(complex complex) equ-complex)
    `done)
(define (equ? a b)
    (apply-generic `equal a b))
(define (install-equzero-package)
    (define (equ-zero-number x)
        (= x 0))
    (define (equ-zero-rat x)
        (and (= (number x) 0)
             (not (= (denom x) 0))))
    (define (equ-zero-complex x)
        (= (magnitude x) 0))
    (put `=zero? `scheme-number equ-zero-number)
    (put `=zero? `rational equ-zero-rat)
    (put `=zero? `complex equ-zero-complex)
    `done)
(define (=zero? a)
    (apply-generic `=zero? a))
(define (apply-generic op . args)
    (let ((type-tags (map type-tag args)))
        (let ((proc (get op type-tags)))
            (if proc
                (drop (apply proc (map contents args)))
                (if (= (length args) 2)
                    (let ((type1 (car type-tags))
                          (type2 (car (cdr type-tags))))
                          (if (eq? type1 type2)
                            (display "No method for this type" type1)
                            (let ((pos1 (check-from-tower type1 tower))
                                  (pos2 (check-from-tower type2 tower))
                                  (a1 (car args))
                                  (a2 (car (cdr args))))
                                  (if (< pos1 pos2)
                                    (apply-generic op (raise a1) a2)
                                    (apply-generic op a1 (raise a2))))))
                    (display "No method for these types" (list op type-tags)))))))
(define (raise arg)
    (let ((tags (car arg)))
        (if tags
            (apply `raise tags arg)
            (display "Bad Data Format"))))
(define (install-raise-package)
    (define (raise-number n)
        (make-rat n 1))
    (define (raise-rational r)
        (/ (number r) (denom r)))
    (define (raise-real r)
        (make-complex-real-imag r 0))
    (put `raise `scheme-number raise-number)
    (put `raise `rational raise-rational)
    (put `raise `real-number raise-real)
    `done)
(define tower `())
(define (check-from-tower tower type)
    (define (check iter type tower)
        (cond ((null? tower) (display "No mathcing types"))
              ((eq? (car tower) type) iter)
              (else (check (+ iter 1) type (cdr tower)))))
    (check 1 type tower))
(define (drop x)
    (if (equ? x (project x))
        (drop (project x))
        x))
(define (project x)
    (apply-generic `project x))
(define (install-project-package)
    (define (project-complex x)
        (real x))
    (define (project-real r)
        (make-rat (round r) 1))
    (define (project-rat r)
        (number r))
    (put `project `complex project-complex)
    (put `project `real-number project-real)
    (put `project `rational project-rat)
    `done)
(define (=zero-poly? p)
    (cond ((null? p) #t)
    (else (if (=zero? (coeff (car p)))
        (=zero-poly? (cdr p))
        #f))))
(put `=zero? `polynomial =zero-poly?)
(define (get-coeff order term-list)
    (define highest (length term-list))
    (define (iter cnt term-list)
        (if (= cnt (- highest order))
            (car term-list)
            (iter (+ cnt 1) (cdr term-list))))
    (iter 0 term-list))

