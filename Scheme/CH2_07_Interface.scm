#lang racket

; This is an exercise program in <SICP> CH2.
; Mainly about Interface like map or filter.
; Author : Brethland, Early 2019.

(define (accumulate op initial seq)
    (if (null? seq)
        initial
       (op (car seq)
            (accumulate op initial (cdr seq)))))
; (define (map p seq)
;     (accumulate (lambda (x y) (cons (p x) y)) `() seq))
(define (append seq1 seq2)
    (accumulate cons seq2 seq1))
(define (length seq)
    (accumulate (lambda (x y) (+ 1 y)) 0 seq))
(define (square x)
    (* x x))
(define lis1 (list 1 2 3 4 5))
(define lis2 (list 6 7 8))
; (map square lis1)
; (append lis1 lis2)
; (length lis1)
(define (horner-eval x coefficent-sequence)
    (accumulate (lambda (this-coeff higher-terms) (+ this-coeff (* x higher-terms)))
                0
                coefficent-sequence))
; (horner-eval 2 (list 1 3 0 5 0 1))
(define (enumurate-tree tree)
    (cond ((null? tree) `())
          ((not (pair? tree)) (list tree))
          (else (append (enumurate-tree (car tree))
                        (enumurate-tree (cdr tree))))))
(define (count-leaves t)
    (accumulate + 0 (map (lambda (x)
                                 (if (not (pair? x))
                                      1
                                      (count-leaves x))) t)))
; (count-leaves (list 1 (list 2 (list 3 4)) 5))
(define (accumulate-n op init seqs)
    (if (null? (car seqs))
        `()
        (cons (accumulate op init (map (lambda (x) (car x)) seqs))
              (accumulate-n op init (map (lambda (x) (cdr x)) seqs)))))
; (accumulate-n + 0 (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))
(define (dot-product v w)
    (accumulate + 0 (map * v w)))
(define (martrix-*-vector m v)
    (map (lambda (x) (dot-product x v)) m))
(define (transpose mat)
    (accumulate-n cons `() mat))
(define (martrix-*-martrix m n)
    (let ((cols (transpose n)))
        (map (lambda (x) (martrix-*-vector cols x)) m)))
(define (reverse sequence)
    (accumulate (lambda (x y) (append y (list x))) `() sequence))
; (define (reverse sequence)
;     (fold-left (lambda (x y) (cons y x)) `() sequence))
(define (enumurate-interval low high)
    (if (> low high)
        `()
        (cons low (enumurate-interval (+ low 1) high))))
(define (flatmap proc sequence)
    (accumulate append `() (map proc sequence)))
(define (unique-pairs n)
    (flatmap (lambda (i) (map (lambda (j) (list i j)) (enumurate-interval 1 (- i 1)))) (enumurate-interval 1 n)))
; (define (prime-sum-pairs n)
;     (filter prime-sum? (unique-pairs n)))
(define (unique-three-pairs n)
    (flatmap (lambda (i) (flatmap (lambda (j)  
                                        (map (lambda (k) (list i j k)) (enumurate-interval 1 (- j 1))))
                                (enumurate-interval 1 (- i 1))))
            (enumurate-interval 1 n)))
; (unique-pairs 6)
; (unique-three-pairs 6)
(define (filter predicate sequence)
    (cond ((null? sequence) `())
          ((predicate (car sequence))
           (cons (car sequence)
                 (filter predicate (cdr sequence))))
          (else (filter predicate (cdr sequence)))))
(define (sum-three-equals-s n s)
    (define (sum-equals-s? sequence)
        (= (+ (car sequence)
            (car (cdr sequence))
            (car (cdr (cdr sequence))))
            s))
    (filter sum-equals-s? (unique-three-pairs n)))
; (sum-three-equals-s 6 6)
(define (get-kth-number sequence k)
    (if (= k 1)
        (car sequence)
        (get-kth-number (cdr sequence) (- k 1))))
(define (kick-last sequence)
    (if (null? (cdr sequence))
        `()
        (cons (car sequence)
            (kick-last (cdr sequence)))))
(define (not-equals-m? m sequence)
    (if (null? sequence)
        #t
    (and (not (= (car sequence) m))
        (not-equals-m? m (cdr sequence)))))
(define (angle-line? m k sequence)
    (define start-row (- m (- k 1)))
    (define (iter row seq)
        (if (null? seq)
            #t
        (and (not (= (car seq) row))
            (iter (cdr seq) (+ row 1)))))
    (iter start-row sequence))
(define (trans-angle-line? m k sequence)
    (define start-row (+ m (- k 1)))
    (define (iter row seq)
        (if (null? seq)
            #t
        (and (not (= (car seq) row))
            (iter (cdr seq) (- row 1)))))
    (iter start-row sequence))
