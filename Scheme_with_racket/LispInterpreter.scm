#lang R5RS

; This is a Lisp Interpreter.
; Some code comes from <SICP>.
; Author : Brethland, Late 2019.

(define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp))
          ((quoted? exp) (text-of-quotation exp))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((lambda? exp) (make-procedure (lambda-parameters exp)
                                         (lambda-body exp)
                                         env))
          ((begin? exp) (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((application? exp) (apply (eval (operator exp) env) (list-of-values (oprands exp) env)))
          (else (display "Unknown expression type -- EVAL" exp))))
(define (apply procedure arguments)
    (cond ((primitive-procedure? procedure)
            (apply-primitive-procedure procedure arguments))
          ((compound-procedure? procedure)
            (eval-sequence
                (procedure-body procedure)
                (extend-environment (procedure-parameters procedure) arguments (procedure-environment procedure))))
          (else (display "Unknown procedure type -- APPLY" procedure))))
(define (list-of-values exps env)
    (if (no-oprands? exps)
        `()
        (cons (eval (first-oprand exps) env)
              (list-of-values (rest-oprands exps) env))))
(define (eval-if exp env)
    (if (true? (eval (if-predicate exp) env))
        (eval (if-consequent exp) env)
        (eval (if-alternative exp) env)))
(define (eval-sequence exps env)
    (cond ((last-exp? exps) (eval (fisrt-exp exps) env))
        (else (eval (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))
(define (eval-assignment exp env)
    (set-variable-value! (assignment-variable exp)
                         (eval (assignment-value exp) env)
                         env)
    `ok)
(define (eval-definition exp env)
    (define-variable! (definition-variable exp)
                      (eval (definition-value exp) env)
                      env)
    `ok)
(define (self-evaluating? exp)
    (cond ((number? exp) #t)
          ((string? exp) #t)
          (else #f)))
(define (variable? exp) (symbol? exp))
(define (quoted? exp)
    (tagged-list? exp `quote))
(define (text-of-quotation exp) (car (cdr exp)))
(define (tagged-list? exp tag)
    (if (pair? exp)
        (eq? (car exp) tag)
        #f))
(define (assignment? exp)
    (tagged-list? exp `set!))
(define (assignment-variable exp) (car (cdr exp)))
(define (assignment-value exp) (car (cdr (cdr exp))))
(define (definition? exp)
    (tagged-list? exp `define))
(define (definition-variable exp)
    (if (symbol? (car (cdr exp)))
        (car (cdr exp))
        (car (car (cdr exp)))))
(define (definition-value exp)
    (if (symbol? (car (cdr exp)))
        (car (cdr (cdr exp)))
        (make-lambda (cdr (car (cdr exp)))
                     (cdr (cdr exp)))))
(define (lambda? exp) (tagged-list? exp `lambda))
(define (lambda-parameters exp) (car (cdr exp)))
(define (lambda-body exp) (cdr (cdr exp)))
(define (make-lambda parameters body)
    (cons `lambda (cons parameters body)))
(define (if? exp) (tagged-list? exp `if))
(define (if-predicate exp) (car (cdr exp)))
(define (if-consequent exp) (car (cdr (cdr exp))))
(define (if-alternative exp)
    (if (not (null? (cdr (cdr (cdr exp)))))
        (car (cdr (cdr (cdr exp))))
        #f))
(define (make-if predicate consequent alternative)
    (list `if predicate consequent alternative))
(define (begin? exp) (tagged-list? exp `begin))
(define (begin-action exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))
(define (sequence->exp seq)
    (cond ((null? seq) seq)
          ((last-exp? seq) (first-exp seq))
          (else (make-begin seq))))
(define (make-begin seq) (cons `begin seq))
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-oprand ops) (car ops))
(define (rest-operands ops) (cdr ops))
(define (cond? exp) (tagged-list? exp `cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
    (eq? (cond-predicate clause) `else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
    (expand-clauses (cond-clauses exp)))
(define (expand-clauses clauses)
    (if (null? clauses)
        `false
        (let ((first (car clauses))
              (rest (cdr clauses)))
            (if (cond-else-clause? first)
                (if (null? rest)
                    (sequence->exp (cond-actions first))
                    (display "ELSE clause isn't last -- COND->IF" clauses))
                (make-if (cond-predicate first)
                         (sequence->exp (cond-actions first))
                         (expand-clauses rest))))))
(define (or? exp) (tagged-list? exp `or))
(define (and? exp) (tagged-list? exp `and))
(define (or-body exp) (cdr exp))
(define (and-body exp) (cdr exp))
(define (first-predicate exp) (car exp))
(define (rest-predicate exp) (car exp))
(define (eval-or clauses env)
    (if (null? clauses)
        #f
        (if (true? (eval (first-predicate clauses) env))
            #t
            (eval-or (rest-predicate clauses) env))))
(define (eval-and clauses env)
    (if (null? clauses)
        #t
        (if (false? (eval (first-predicate clauses) env))
            #f
            (eval-and (rest-predicate clauses) env))))
(define (cond-form-predicate clause) (car clause))
(define (cond-form-process clause) (car (cdr (cdr clause))))
(define (cond-form stream env)
    (if (null? (cdr stream))
        (if (eq? `else (cond-form-predicate (car stream)))
            (car (cdr (car stream)))
            #f)
        (let ((first (car stream))
              (second (cdr stream))
              (eval-value (eval (cond-form-predicate first) env)))
            (cond ((eq? eval-value `else) (display "ERROR ELSE isn't an end. --COND-FORM" first))
                  ((true? eval-value) ((cond-form-process first) eval-value))
                  (else (cond-form second env))))))
(define (let-variable-list exp) (car (cdr exp)))
(define (get-variable-list exp)
    (if (null? exp)
        `()
        (cons (car (car exp))
            (get-variable-list (cdr exp)))))
(define (get-arguments-list exp)
    (if (null? exp)
        `()
        (cons (cdr (car exp))
            (get-arguments-list (cdr exp)))))
(define (let->combination exp)
    (append (make-lambda (get-variable-list (let-variable-list exp))
                        (car (cdr (cdr exp))))
            (get-arguments-list (let-variable-list exp))))
; (define (make-let variable-list)
;     (list `let variable-list))
; (define (let*->nested-lets exp)
;     (let ((variable-list) (get-variable-list exp))
;         (define (iter result exp)
;         (cond ((null? (cdr exp)) (cons result (make-let (car exp))))
;               (else (iter (cons result (make-let (car exp)))
;                             (cdr exp)))))
;         (iter `() variable-list)))
; (define (for? exp) (tagged-list? exp `for))
; (define (for-to-lambda exp)
;     (let ((predicate (cadr exp))
;           (iter-function (caddr exp))
;           (function (cadddr exp))
;           (init-value (caddddr exp)))
;     `((define (lamdba-func it)
;         (cond (((not (predicate it)) `())
;                   (else (begin function (lambda-func (iter-function it)))))))
;       (lambda-func init-value))))
(define (true? x)
    (not (eq? x false)))
(define (false? x)
    (eq? x false))