; This is an exercise program in <SICP> CH4.
; Mainly about the amb and undetermined calculation.
; Author : Brethland. Late 2019.

(define (an-interger-between low high)
    (require (<= low high))
    (amb low (an-interger-between (+ low 1) high)))
(define (logical-solving)
    (let ((fletcher (amb 2 3 4))
          (cooper (amb 2 3 4 5))
          (baker (amb 1 2 3 4))
          (miller (amb 1 2 3 4 5)))
        (require (> miller cooper))
        (require (not (= (abs (- fletcher cooper)) 1)))
        (let ((smith (amb 1 2 3 4 5)))
            (require (not (= (abs (- fletcher smith)) 1)))
            (list (list `baker baker)
                  (list `cooper cooper)
                  (list `fletcher fletcher)
                  (list `miller miller)
                  (list `smith smith)))))
(define (xor a b)
    (or (and (not a) b) (and a (not b))))
(define (solve)
    (let ((betty (amb 1 2 3 4 5))
          (esier (amb 1 2 3 4 5))
          (jone  (amb 1 2 3 4 5))
          (ketty (amb 1 2 3 4 5))
          (mary  (amb 1 2 3 4 5)))
        (require (xor (= ketty 2) (= betty 3)))
        (require (xor (= esier 1) (= jone  2)))
        (require (xor (= jone  3) (= esier 5)))
        (require (xor (= ketty 2) (= mary  4)))
        (require (xor (= mary  4) (= betty 1)))
        (require (distinct? (list betty esier jone ketty mary)))
        (list (cons `betty betty)
              (cons `esier esier)
              (cons `jone  jone )
              (cons `ketty ketty)
              (cons `mary  mary ))))
(define (queens board-size)
 (define (new-queen a b) 
     (require (<= a b)) 
     (amb a (new-queen (+ a 1) b))) 
  (define (iter positions)
    (require (distinct? (map cdr positions)))
    (require (distinct? (map (lambda (q) (- (car q) (cdr q))) positions)))
    (require (distinct? (map (lambda (q) (+ (car q) (cdr q))) positions)))
    (if (= board-size (length positions))
        (reverse (map cdr positions))
        (iter (cons (new-queen 1 board-size) positions))))
  (iter '()))
(define (parse-word word-list)
    (require (not (null? *unparsed*)))
    (let ((found-word (amb (cadr word-list) (cddr word-list))))
        (set! *unparsed* (cdr *unparsed*))
        (list (car word-list) found-word)))
(define (analyze-ramb exp)
    (let ((cprocs (map analyze (amb-choices exp))))
        (lambda (env succeed fail)
            (define (try-next choices)
                (if (null? choices)
                    (fail)
                    (let ((randref (rand (length choices))))
                        ((list-ref (- randref 1))
                         env
                         succeed
                         (lambda () (try-next (del-list choices randref)))))))
            (try-next cprocs))))
(define (analyze-if-fail exp)
    (let ((cprocs (analyze (cadr  exp)))
          (aprocs (analyze (caddr exp))))
        (lambda (env succeed fail)
            (cprocs
                env
                (lambda (evalue fail2)
                    (evalue proc succeed fail2))
                (aprocs proc succeed fail)))))
; (false? pred-value)
; fail